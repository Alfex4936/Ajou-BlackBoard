import json
import os
import ssl
from datetime import datetime
from urllib.error import HTTPError, URLError
from urllib.request import urlopen

from selectolax.parser import HTMLParser


class Homepage:
    __slots__ = ()

    @staticmethod
    def checkConnection():
        """ 홈페이지 반응을 체크한다. """
        context = ssl._create_unverified_context()
        try:
            urlopen(
                url="https://www.ajou.ac.kr/kr/ajou/notice.do",
                timeout=3.0,
                context=context,
            )
        except HTTPError:
            print("Seems like the server is down now.")
            return False
        except URLError:
            print("Seems like the url is wrong now.")
            return False
        except TimeoutError:
            print("It's taking too long to load website.")
            return False
        return True  # the connection automatically is closed

    @staticmethod
    def parseNotices(url=None, length=30):
        ADDRESS = "https://www.ajou.ac.kr/kr/ajou/notice.do"

        """공지 파서 메인

        Args:
            url (str, optional): 홈페이지 URL (with admin options). Defaults to None.
            length (int, optional): 몇 개의 공지를 읽을 것인가. Defaults to 10.

        Returns:
            ids, posts, dates, writers, length (list, optional): length에 따른 공지 목록을 전부 불러온다.
        """
        if url is None:
            url = f"{ADDRESS}?mode=list&articleLimit={length}&article.offset=0"

        context = ssl._create_unverified_context()
        try:
            result = urlopen(url, timeout=3.0, context=context)
        except HTTPError:
            print("Seems like the server is down now.")
            return None, None  # make entity
        except TimeoutError:
            print("It's taking too long to load website.")
            return None, None  # make entity

        html = result.read().decode("utf-8")
        soup = HTMLParser(html)
        no_post = soup.css_first("td.b-no-post")
        if no_post:
            return None, None  # make entity

        ids = soup.css("td.b-num-box")
        posts = soup.css("div.b-title-box > a")
        # links will be generated by posts[i] href
        dates = soup.css("span.b-date")
        writers = soup.css("span.b-writer")

        ids = soup.css("td.b-num-box")
        posts = soup.css("div.b-title-box > a")
        dates = soup.css("span.b-date")
        writers = soup.css("span.b-writer")

        notices = []
        append = notices.append

        todayIdx = None
        now = datetime.now()
        now = now.strftime("%y.%m.%d")

        for i in range(len(ids)):
            date = dates[i].text(strip=True)
            if todayIdx is None and date != now:
                if i != 0:
                    todayIdx = i

            title = posts[i].text(strip=True)
            writer = writers[i].text(strip=False)

            duplicate = "[" + writer + "]"
            if duplicate in title:  # writer: [writer] title
                title = title.replace(duplicate, "").strip()  # -> writer: title
            del duplicate

            notice = Notice(
                ids[i].text(strip=True),
                title,
                date if date != now else "오늘",
                writer,
                ADDRESS + posts[i].attributes["href"],
            )
            append(notice)

        return notices, todayIdx

    # https://library.ajou.ac.kr/smufu-api/pc/1/rooms-at-seat?branchGroupId=1
    @staticmethod
    def loadLibrary():
        context = ssl._create_unverified_context()
        try:
            result = urlopen(os.environ["AJOU_LIBRARY"], timeout=3.0, context=context)
        except HTTPError:
            print("Seems like the server is down now.")
            return None  # make entity
        except TimeoutError:
            print("It's taking too long to load website.")
            return None  # make entity

        jsonData = result.read().decode("utf-8")
        return json.loads(jsonData)


class Notice:
    __slots__ = ("_id", "_post", "_date", "_link", "_writer")

    def __init__(self, id, post, date, writer, link):
        self._id = id
        self._post = post
        self._date = date
        self._writer = writer
        self._link = link

    def getAttrs(self, *attrs):
        result = [None] * len(attrs)
        if not attrs:
            return result

        for i, attr in enumerate(attrs):
            result[i] = getattr(self, attr)

        return result

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, id):
        self._id = id

    @property
    def title(self):
        return self._post

    @title.setter
    def title(self, title):
        self._post = title

    @property
    def date(self):
        return self._date

    @date.setter
    def date(self, date):
        self._date = date

    @property
    def writer(self):
        return self._writer

    @writer.setter
    def writer(self, writer):
        self._writer = writer

    @property
    def link(self):
        return self._link

    @link.setter
    def link(self, link):
        self._link = link


if __name__ == "__main__":
    notice = Notice("2020", "title", "date", "writer", "link")
